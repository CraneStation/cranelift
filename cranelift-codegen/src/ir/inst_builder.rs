//! TODO

use crate::ir::builder::InstBuilderBase;
use crate::ir::immediates::Imm64;
use crate::ir::{self, types};
use crate::ir::{DataFlowGraph, Inst, InstructionData, Opcode, Type, Value, ValueDef};
use crate::isa;

// Include trait code generated by `cranelift-codegen/meta/src/gen_inst.rs`.
//
// This file defines the `InstBuilder` trait as an extension of `InstBuilderBase` with methods per
// instruction format and per opcode.
include!(concat!(env!("OUT_DIR"), "/inst_builder.rs"));

fn try_unwrap_iconst(dfg: &DataFlowGraph, value: Value) -> Option<i64> {
    if let ValueDef::Result(inst, _) = dfg.value_def(value) {
        if let InstructionData::UnaryImm {
            opcode: Opcode::Iconst,
            imm,
        } = dfg[inst]
        {
            return Some(i64::from(imm));
        }
    }
    None
}

/// Any type implementing `InstBuilderBase` gets all the `InstBuilder` methods for free, with
/// some special enhancements for free.
impl<'f, T: InstBuilderBase<'f>> InstBuilder<'f> for T {
    fn iadd(self, x: ir::Value, y: ir::Value) -> Value {
        let dfg = self.data_flow_graph();
        let ty = dfg.value_type(x);
        if ty == dfg.value_type(y) {
            // See if one of the operands is a constant immediate.
            if let Some(y_imm) = try_unwrap_iconst(dfg, y) {
                // Otherwise, we can emit iadd_imm.
                return self.iadd_imm(x, y_imm);
            }
            if let Some(x_imm) = try_unwrap_iconst(dfg, x) {
                // Add is commutative, try the other way around.
                return self.iadd_imm(y, x_imm);
            }
        }
        InstBuilder::default_iadd(self, x, y)
    }

    fn iadd_imm<T1imm64: Into<ir::immediates::Imm64>>(self, x: ir::Value, imm: T1imm64) -> Value {
        let dfg = self.data_flow_graph();
        let imm = i64::from(imm.into());
        // x + 0 == x
        if imm == 0 {
            return x;
        }
        if let Some(x_imm) = try_unwrap_iconst(dfg, x) {
            let cst = Imm64::from(imm + x_imm);
            let ty = dfg.value_type(x);
            return self.iconst(ty, cst);
        }
        InstBuilder::default_iadd_imm(self, x, imm)
    }
}

#[cfg(test)]
mod tests {
    use crate::cursor::{Cursor, FuncCursor};
    use crate::ir::types::*;
    use crate::ir::{Function, InstBuilder, InstructionData, Opcode, ValueDef};

    #[test]
    fn constant_folding() {
        let mut func = Function::new();
        let ebb0 = func.dfg.make_ebb();
        let arg0 = func.dfg.append_ebb_param(ebb0, I32);
        let mut pos = FuncCursor::new(&mut func);
        pos.insert_ebb(ebb0);

        let x = pos.ins().iconst(I32, 13);
        let y = pos.ins().iconst(I32, 37);

        // Adding two constants together yields a constant.
        let iadd = pos.ins().iadd(x, y);
        if let ValueDef::Result(inst, _) = pos.func.dfg.value_def(iadd) {
            if let InstructionData::UnaryImm {
                opcode: Opcode::Iconst,
                imm,
            } = pos.func.dfg[inst]
            {
                assert_eq!(i64::from(imm), 13 + 37);
            } else {
                panic!("not iconst");
            }
        } else {
            panic!("iadd has no results")
        }

        // Adding a 0 constant to an input yields the input.
        let y = pos.ins().iconst(I32, 0);
        let iadd = pos.ins().iadd(x, y);
        assert_eq!(iadd, x);

        // Adding a constant to the left input yields iadd_imm.
        let y = pos.ins().iconst(I32, 42);
        let iadd = pos.ins().iadd(arg0, y);
        if let ValueDef::Result(inst, _) = pos.func.dfg.value_def(iadd) {
            if let InstructionData::BinaryImm {
                opcode: Opcode::IaddImm,
                imm,
                arg,
            } = pos.func.dfg[inst]
            {
                assert_eq!(i64::from(imm), 42);
                assert_eq!(arg, arg0);
            } else {
                panic!("not iadd_imm")
            }
        } else {
            panic!("iadd has no results")
        }

        // Adding a constant to the right input yields iadd_imm.
        let y = pos.ins().iconst(I32, 42);
        let iadd = pos.ins().iadd(y, arg0);
        if let ValueDef::Result(inst, _) = pos.func.dfg.value_def(iadd) {
            if let InstructionData::BinaryImm {
                opcode: Opcode::IaddImm,
                imm,
                arg,
            } = pos.func.dfg[inst]
            {
                assert_eq!(i64::from(imm), 42);
                assert_eq!(arg, arg0);
            } else {
                panic!("not iadd_imm");
            }
        } else {
            panic!("iadd has no results");
        }
    }
}
